import torch
import torch.nn.functional as F
import numpy as np
import random
from scipy import ndimage
import scipy
import scipy.stats as ss
from scipy.interpolate import interp2d
from scipy.linalg import orth
import albumentations

from torchvision.transforms.functional import rgb_to_grayscale

# ... existing code ... 

def circular_lowpass_kernel(cutoff, kernel_size, pad_to=0):
    """2D sinc filter, ref: https://dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter
    """
    assert kernel_size % 2 == 1, 'Kernel size must be an odd number.'
    kernel = torch.zeros((kernel_size, kernel_size))
    kernel_center = kernel_size // 2
    for i in range(kernel_size):
        for j in range(kernel_size):
            di2, dj2 = (i - kernel_center) ** 2, (j - kernel_center) ** 2
            kernel[i, j] = torch.exp(-cutoff * (di2 + dj2))
    kernel = kernel / kernel.sum()
    if pad_to > kernel_size:
        pad_size = (pad_to - kernel_size) // 2
        kernel = torch.nn.functional.pad(kernel, (pad_size, pad_size, pad_size, pad_size))
    return kernel

def random_mixed_kernels(kernel_list,
                        kernel_prob,
                        kernel_size=21,
                        sigma_x_range=(0.6, 5),
                        sigma_y_range=(0.6, 5),
                        rotation_range=(-3.14, 3.14),
                        betag_range=(0.5, 8),
                        betap_range=(0.5, 8),
                        noise_range=None):
    """Randomly generate mixed kernels.
    """
    kernel_type = random.choices(kernel_list, kernel_prob)[0]
    if kernel_type == 'iso':
        kernel = random_bivariate_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, noise_range=noise_range)
    elif kernel_type == 'aniso':
        kernel = random_bivariate_anisotropic_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, noise_range=noise_range)
    elif kernel_type == 'generalized_iso':
        kernel = random_bivariate_generalized_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, betag_range, noise_range=noise_range)
    elif kernel_type == 'generalized_aniso':
        kernel = random_bivariate_generalized_anisotropic_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, betag_range, betap_range, noise_range=noise_range)
    elif kernel_type == 'plateau_iso':
        kernel = random_bivariate_plateau_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, betap_range, noise_range=noise_range)
    elif kernel_type == 'plateau_aniso':
        kernel = random_bivariate_plateau_anisotropic_gaussian_kernel(
            kernel_size, sigma_x_range, sigma_y_range, rotation_range, betap_range, noise_range=noise_range)
    else:
        raise ValueError(f'Unknown kernel type: {kernel_type}')
    return kernel 